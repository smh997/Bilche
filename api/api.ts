// tslint:disable
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


 import * as globalImportUrl from 'url';
 import { Configuration } from './configuration';
 import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
 // Some imports not used depending on template conditions
 // @ts-ignore
 import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';
 
 /**
  * 
  * @export
  * @interface BasePlantList
  */
 export interface BasePlantList {
     /**
      * 
      * @type {number}
      * @memberof BasePlantList
      */
     id?: number;
     /**
      * 
      * @type {string}
      * @memberof BasePlantList
      */
     title: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantList
      */
     picture?: string;
 }
 /**
  * 
  * @export
  * @interface BasePlantObject
  */
 export interface BasePlantObject {
     /**
      * 
      * @type {number}
      * @memberof BasePlantObject
      */
     id?: number;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     common_names?: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     categories?: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     pictures?: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     waterings?: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     fertilizers?: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     colors?: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     like?: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     title: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     scientific_name: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     family: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     level?: BasePlantObjectLevelEnum;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     need_to_check: BasePlantObjectNeedToCheckEnum;
     /**
      * 
      * @type {boolean}
      * @memberof BasePlantObject
      */
     fogging?: boolean;
     /**
      * 
      * @type {boolean}
      * @memberof BasePlantObject
      */
     pruning?: boolean;
     /**
      * 
      * @type {boolean}
      * @memberof BasePlantObject
      */
     cleaning_leaves?: boolean;
     /**
      * 
      * @type {boolean}
      * @memberof BasePlantObject
      */
     cleaning_pot?: boolean;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     light: BasePlantObjectLightEnum;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     temperature: BasePlantObjectTemperatureEnum;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     humidity: BasePlantObjectHumidityEnum;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     soil_type: BasePlantObjectSoilTypeEnum;
     /**
      * 
      * @type {boolean}
      * @memberof BasePlantObject
      */
     toxic?: boolean;
     /**
      * 
      * @type {boolean}
      * @memberof BasePlantObject
      */
     irritant?: boolean;
     /**
      * 
      * @type {number}
      * @memberof BasePlantObject
      */
     life_span: number;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     flower_time: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     leaf_time: string;
     /**
      * 
      * @type {number}
      * @memberof BasePlantObject
      */
     max_height: number;
     /**
      * 
      * @type {number}
      * @memberof BasePlantObject
      */
     max_width: number;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     flower_type: string;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     leaf_type: string;
     /**
      * 
      * @type {number}
      * @memberof BasePlantObject
      */
     change_pot?: number | null;
     /**
      * 
      * @type {string}
      * @memberof BasePlantObject
      */
     pot_type?: BasePlantObjectPotTypeEnum;
 }
 
 /**
     * @export
     * @enum {string}
     */
 export enum BasePlantObjectLevelEnum {
     E = 'e',
     M = 'm',
     H = 'h'
 }
 /**
     * @export
     * @enum {string}
     */
 export enum BasePlantObjectNeedToCheckEnum {
     No = 'no',
     Aw = 'aw',
     _1w = '1w',
     _2w = '2w'
 }
 /**
     * @export
     * @enum {string}
     */
 export enum BasePlantObjectLightEnum {
     D = 'd',
     I = 'i',
     L = 'l',
     A = 'a'
 }
 /**
     * @export
     * @enum {string}
     */
 export enum BasePlantObjectTemperatureEnum {
     R = 'r'
 }
 /**
     * @export
     * @enum {string}
     */
 export enum BasePlantObjectHumidityEnum {
     D = 'd',
     N = 'n',
     H = 'h'
 }
 /**
     * @export
     * @enum {string}
     */
 export enum BasePlantObjectSoilTypeEnum {
     W = 'w',
     L = 'l',
     C = 'c'
 }
 /**
     * @export
     * @enum {string}
     */
 export enum BasePlantObjectPotTypeEnum {
     P = 'p',
     E = 'e'
 }
 
 /**
  * 
  * @export
  * @interface Email
  */
 export interface Email {
     /**
      * 
      * @type {string}
      * @memberof Email
      */
     email: string;
 }
 /**
  * 
  * @export
  * @interface Feedback
  */
 export interface Feedback {
     /**
      * 
      * @type {string}
      * @memberof Feedback
      */
     fullname?: string;
     /**
      * 
      * @type {string}
      * @memberof Feedback
      */
     email?: string | null;
     /**
      * 
      * @type {string}
      * @memberof Feedback
      */
     text: string;
 }
 /**
  * 
  * @export
  * @interface InlineResponse200
  */
 export interface InlineResponse200 {
     /**
      * 
      * @type {number}
      * @memberof InlineResponse200
      */
     count?: number;
     /**
      * 
      * @type {string}
      * @memberof InlineResponse200
      */
     next?: string | null;
     /**
      * 
      * @type {string}
      * @memberof InlineResponse200
      */
     previous?: string | null;
     /**
      * 
      * @type {Array<BasePlantList>}
      * @memberof InlineResponse200
      */
     results?: Array<BasePlantList>;
 }
 /**
  * 
  * @export
  * @interface Installapp
  */
 export interface Installapp {
     /**
      * 
      * @type {number}
      * @memberof Installapp
      */
     id?: number;
     /**
      * 
      * @type {string}
      * @memberof Installapp
      */
     application_store: InstallappApplicationStoreEnum;
 }
 
 /**
     * @export
     * @enum {string}
     */
 export enum InstallappApplicationStoreEnum {
     Sa = 'sa',
     S = 's',
     B = 'b',
     G = 'g',
     D = 'd'
 }
 
 /**
  * 
  * @export
  * @interface MyAuthToken
  */
 export interface MyAuthToken {
     /**
      * 
      * @type {string}
      * @memberof MyAuthToken
      */
     username: string;
     /**
      * 
      * @type {string}
      * @memberof MyAuthToken
      */
     password: string;
     /**
      * 
      * @type {string}
      * @memberof MyAuthToken
      */
     token?: string;
 }
 /**
  * 
  * @export
  * @interface PasswordToken
  */
 export interface PasswordToken {
     /**
      * 
      * @type {string}
      * @memberof PasswordToken
      */
     password: string;
     /**
      * 
      * @type {string}
      * @memberof PasswordToken
      */
     token: string;
 }
 /**
  * 
  * @export
  * @interface Subscribe
  */
 export interface Subscribe {
     /**
      * 
      * @type {string}
      * @memberof Subscribe
      */
     email_phone: string;
 }
 /**
  * 
  * @export
  * @interface User
  */
 export interface User {
     /**
      * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
      * @type {string}
      * @memberof User
      */
     username?: string;
     /**
      * 
      * @type {string}
      * @memberof User
      */
     password: string;
     /**
      * 
      * @type {string}
      * @memberof User
      */
     email: string;
     /**
      * 
      * @type {string}
      * @memberof User
      */
     level?: UserLevelEnum;
     /**
      * 
      * @type {string}
      * @memberof User
      */
     fullname?: string;
     /**
      * 
      * @type {string}
      * @memberof User
      */
     phone_number?: string | null;
     /**
      * 
      * @type {any}
      * @memberof User
      */
     profile_photo?: any | null;
     /**
      * 
      * @type {boolean}
      * @memberof User
      */
     is_gardener?: boolean;
     /**
      * 
      * @type {string}
      * @memberof User
      */
     prefered_hour?: string | null;
     /**
      * 
      * @type {string}
      * @memberof User
      */
     _prefered_days?: string;
 }
 
 /**
     * @export
     * @enum {string}
     */
 export enum UserLevelEnum {
     B = 'b',
     M = 'm',
     P = 'p'
 }
 
 
 /**
  * ApiApi - axios parameter creator
  * @export
  */
 export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
     return {
         /**
          * 
          * @param {Email} [email] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createEmail: async (email?: Email, options: any = {}): Promise<RequestArgs> => {
             const localVarPath = `/api/accounts/password_reset/`;
             const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             const needsSerialization = (typeof email !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.data =  needsSerialization ? JSON.stringify(email !== undefined ? email : {}) : (email || "");
 
             return {
                 url: globalImportUrl.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {Feedback} [feedback] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createFeedback: async (feedback?: Feedback, options: any = {}): Promise<RequestArgs> => {
             const localVarPath = `/api/home_page/feedback/`;
             const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             const needsSerialization = (typeof feedback !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.data =  needsSerialization ? JSON.stringify(feedback !== undefined ? feedback : {}) : (feedback || "");
 
             return {
                 url: globalImportUrl.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {Installapp} [installapp] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createInstallapp: async (installapp?: Installapp, options: any = {}): Promise<RequestArgs> => {
             const localVarPath = `/api/home_page/installapp/`;
             const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             const needsSerialization = (typeof installapp !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.data =  needsSerialization ? JSON.stringify(installapp !== undefined ? installapp : {}) : (installapp || "");
 
             return {
                 url: globalImportUrl.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {MyAuthToken} [myAuthToken] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createMyAuthToken: async (myAuthToken?: MyAuthToken, options: any = {}): Promise<RequestArgs> => {
             const localVarPath = `/api/accounts/login/`;
             const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             const needsSerialization = (typeof myAuthToken !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.data =  needsSerialization ? JSON.stringify(myAuthToken !== undefined ? myAuthToken : {}) : (myAuthToken || "");
 
             return {
                 url: globalImportUrl.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {PasswordToken} [passwordToken] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createPasswordToken: async (passwordToken?: PasswordToken, options: any = {}): Promise<RequestArgs> => {
             const localVarPath = `/api/accounts/password_reset/confirm/`;
             const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             const needsSerialization = (typeof passwordToken !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.data =  needsSerialization ? JSON.stringify(passwordToken !== undefined ? passwordToken : {}) : (passwordToken || "");
 
             return {
                 url: globalImportUrl.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {Subscribe} [subscribe] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createSubscribe: async (subscribe?: Subscribe, options: any = {}): Promise<RequestArgs> => {
             const localVarPath = `/api/home_page/subscribe/`;
             const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             const needsSerialization = (typeof subscribe !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.data =  needsSerialization ? JSON.stringify(subscribe !== undefined ? subscribe : {}) : (subscribe || "");
 
             return {
                 url: globalImportUrl.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {User} [user] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createUser: async (user?: User, options: any = {}): Promise<RequestArgs> => {
             const localVarPath = `/api/accounts/register/`;
             const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
             const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
             const needsSerialization = (typeof user !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user !== undefined ? user : {}) : (user || "");
 
             return {
                 url: globalImportUrl.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {string} [toxic] toxic
          * @param {string} [irritant] irritant
          * @param {string} [lifeSpan] life_span
          * @param {string} [pruning] pruning
          * @param {string} [fogging] fogging
          * @param {string} [cleaningPot] cleaning_pot
          * @param {string} [cleaningLeaves] cleaning_leaves
          * @param {string} [search] A search term.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         listBasePlants: async (limit?: number, offset?: number, toxic?: string, irritant?: string, lifeSpan?: string, pruning?: string, fogging?: string, cleaningPot?: string, cleaningLeaves?: string, search?: string, options: any = {}): Promise<RequestArgs> => {
             const localVarPath = `/api/encyclopedia/search/`;
             const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             if (limit !== undefined) {
                 localVarQueryParameter['limit'] = limit;
             }
 
             if (offset !== undefined) {
                 localVarQueryParameter['offset'] = offset;
             }
 
             if (toxic !== undefined) {
                 localVarQueryParameter['toxic'] = toxic;
             }
 
             if (irritant !== undefined) {
                 localVarQueryParameter['irritant'] = irritant;
             }
 
             if (lifeSpan !== undefined) {
                 localVarQueryParameter['life_span'] = lifeSpan;
             }
 
             if (pruning !== undefined) {
                 localVarQueryParameter['pruning'] = pruning;
             }
 
             if (fogging !== undefined) {
                 localVarQueryParameter['fogging'] = fogging;
             }
 
             if (cleaningPot !== undefined) {
                 localVarQueryParameter['cleaning_pot'] = cleaningPot;
             }
 
             if (cleaningLeaves !== undefined) {
                 localVarQueryParameter['cleaning_leaves'] = cleaningLeaves;
             }
 
             if (search !== undefined) {
                 localVarQueryParameter['search'] = search;
             }
 
 
     
             localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: globalImportUrl.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @param {string} id A unique integer value identifying this base plant.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieveBasePlant: async (id: string, options: any = {}): Promise<RequestArgs> => {
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling retrieveBasePlant.');
             }
             const localVarPath = `/api/encyclopedia/plants/{id}/`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
             let baseOptions;
             if (configuration) {
                 baseOptions = configuration.baseOptions;
             }
             const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
 
     
             localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
             localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
 
             return {
                 url: globalImportUrl.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
     }
 };
 
 /**
  * ApiApi - functional programming interface
  * @export
  */
 export const ApiApiFp = function(configuration?: Configuration) {
     return {
         /**
          * 
          * @param {Email} [email] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async createEmail(email?: Email, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Email>> {
             const localVarAxiosArgs = await ApiApiAxiosParamCreator(configuration).createEmail(email, options);
             return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                 const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                 return axios.request(axiosRequestArgs);
             };
         },
         /**
          * 
          * @param {Feedback} [feedback] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async createFeedback(feedback?: Feedback, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedback>> {
             const localVarAxiosArgs = await ApiApiAxiosParamCreator(configuration).createFeedback(feedback, options);
             return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                 const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                 return axios.request(axiosRequestArgs);
             };
         },
         /**
          * 
          * @param {Installapp} [installapp] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async createInstallapp(installapp?: Installapp, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Installapp>> {
             const localVarAxiosArgs = await ApiApiAxiosParamCreator(configuration).createInstallapp(installapp, options);
             return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                 const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                 return axios.request(axiosRequestArgs);
             };
         },
         /**
          * 
          * @param {MyAuthToken} [myAuthToken] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async createMyAuthToken(myAuthToken?: MyAuthToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MyAuthToken>> {
             const localVarAxiosArgs = await ApiApiAxiosParamCreator(configuration).createMyAuthToken(myAuthToken, options);
             return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                 const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                 return axios.request(axiosRequestArgs);
             };
         },
         /**
          * 
          * @param {PasswordToken} [passwordToken] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async createPasswordToken(passwordToken?: PasswordToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordToken>> {
             const localVarAxiosArgs = await ApiApiAxiosParamCreator(configuration).createPasswordToken(passwordToken, options);
             return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                 const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                 return axios.request(axiosRequestArgs);
             };
         },
         /**
          * 
          * @param {Subscribe} [subscribe] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async createSubscribe(subscribe?: Subscribe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscribe>> {
             const localVarAxiosArgs = await ApiApiAxiosParamCreator(configuration).createSubscribe(subscribe, options);
             return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                 const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                 return axios.request(axiosRequestArgs);
             };
         },
         /**
          * 
          * @param {User} [user] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async createUser(user?: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
             const localVarAxiosArgs = await ApiApiAxiosParamCreator(configuration).createUser(user, options);
             return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                 const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                 return axios.request(axiosRequestArgs);
             };
         },
         /**
          * 
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {string} [toxic] toxic
          * @param {string} [irritant] irritant
          * @param {string} [lifeSpan] life_span
          * @param {string} [pruning] pruning
          * @param {string} [fogging] fogging
          * @param {string} [cleaningPot] cleaning_pot
          * @param {string} [cleaningLeaves] cleaning_leaves
          * @param {string} [search] A search term.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async listBasePlants(limit?: number, offset?: number, toxic?: string, irritant?: string, lifeSpan?: string, pruning?: string, fogging?: string, cleaningPot?: string, cleaningLeaves?: string, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
             const localVarAxiosArgs = await ApiApiAxiosParamCreator(configuration).listBasePlants(limit, offset, toxic, irritant, lifeSpan, pruning, fogging, cleaningPot, cleaningLeaves, search, options);
             return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                 const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                 return axios.request(axiosRequestArgs);
             };
         },
         /**
          * 
          * @param {string} id A unique integer value identifying this base plant.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         async retrieveBasePlant(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasePlantObject>> {
             const localVarAxiosArgs = await ApiApiAxiosParamCreator(configuration).retrieveBasePlant(id, options);
             return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                 const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                 return axios.request(axiosRequestArgs);
             };
         },
     }
 };
 
 /**
  * ApiApi - factory interface
  * @export
  */
 export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
     return {
         /**
          * 
          * @param {Email} [email] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createEmail(email?: Email, options?: any): AxiosPromise<Email> {
             return ApiApiFp(configuration).createEmail(email, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {Feedback} [feedback] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createFeedback(feedback?: Feedback, options?: any): AxiosPromise<Feedback> {
             return ApiApiFp(configuration).createFeedback(feedback, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {Installapp} [installapp] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createInstallapp(installapp?: Installapp, options?: any): AxiosPromise<Installapp> {
             return ApiApiFp(configuration).createInstallapp(installapp, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {MyAuthToken} [myAuthToken] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createMyAuthToken(myAuthToken?: MyAuthToken, options?: any): AxiosPromise<MyAuthToken> {
             return ApiApiFp(configuration).createMyAuthToken(myAuthToken, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {PasswordToken} [passwordToken] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createPasswordToken(passwordToken?: PasswordToken, options?: any): AxiosPromise<PasswordToken> {
             return ApiApiFp(configuration).createPasswordToken(passwordToken, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {Subscribe} [subscribe] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createSubscribe(subscribe?: Subscribe, options?: any): AxiosPromise<Subscribe> {
             return ApiApiFp(configuration).createSubscribe(subscribe, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {User} [user] 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         createUser(user?: User, options?: any): AxiosPromise<User> {
             return ApiApiFp(configuration).createUser(user, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {string} [toxic] toxic
          * @param {string} [irritant] irritant
          * @param {string} [lifeSpan] life_span
          * @param {string} [pruning] pruning
          * @param {string} [fogging] fogging
          * @param {string} [cleaningPot] cleaning_pot
          * @param {string} [cleaningLeaves] cleaning_leaves
          * @param {string} [search] A search term.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         listBasePlants(limit?: number, offset?: number, toxic?: string, irritant?: string, lifeSpan?: string, pruning?: string, fogging?: string, cleaningPot?: string, cleaningLeaves?: string, search?: string, options?: any): AxiosPromise<InlineResponse200> {
             return ApiApiFp(configuration).listBasePlants(limit, offset, toxic, irritant, lifeSpan, pruning, fogging, cleaningPot, cleaningLeaves, search, options).then((request) => request(axios, basePath));
         },
         /**
          * 
          * @param {string} id A unique integer value identifying this base plant.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieveBasePlant(id: string, options?: any): AxiosPromise<BasePlantObject> {
             return ApiApiFp(configuration).retrieveBasePlant(id, options).then((request) => request(axios, basePath));
         },
     };
 };
 
 /**
  * ApiApi - interface
  * @export
  * @interface ApiApi
  */
 export interface ApiApiInterface {
     /**
      * 
      * @param {Email} [email] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApiInterface
      */
     createEmail(email?: Email, options?: any): AxiosPromise<Email>;
 
     /**
      * 
      * @param {Feedback} [feedback] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApiInterface
      */
     createFeedback(feedback?: Feedback, options?: any): AxiosPromise<Feedback>;
 
     /**
      * 
      * @param {Installapp} [installapp] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApiInterface
      */
     createInstallapp(installapp?: Installapp, options?: any): AxiosPromise<Installapp>;
 
     /**
      * 
      * @param {MyAuthToken} [myAuthToken] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApiInterface
      */
     createMyAuthToken(myAuthToken?: MyAuthToken, options?: any): AxiosPromise<MyAuthToken>;
 
     /**
      * 
      * @param {PasswordToken} [passwordToken] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApiInterface
      */
     createPasswordToken(passwordToken?: PasswordToken, options?: any): AxiosPromise<PasswordToken>;
 
     /**
      * 
      * @param {Subscribe} [subscribe] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApiInterface
      */
     createSubscribe(subscribe?: Subscribe, options?: any): AxiosPromise<Subscribe>;
 
     /**
      * 
      * @param {User} [user] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApiInterface
      */
     createUser(user?: User, options?: any): AxiosPromise<User>;
 
     /**
      * 
      * @param {number} [limit] Number of results to return per page.
      * @param {number} [offset] The initial index from which to return the results.
      * @param {string} [toxic] toxic
      * @param {string} [irritant] irritant
      * @param {string} [lifeSpan] life_span
      * @param {string} [pruning] pruning
      * @param {string} [fogging] fogging
      * @param {string} [cleaningPot] cleaning_pot
      * @param {string} [cleaningLeaves] cleaning_leaves
      * @param {string} [search] A search term.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApiInterface
      */
     listBasePlants(limit?: number, offset?: number, toxic?: string, irritant?: string, lifeSpan?: string, pruning?: string, fogging?: string, cleaningPot?: string, cleaningLeaves?: string, search?: string, options?: any): AxiosPromise<InlineResponse200>;
 
     /**
      * 
      * @param {string} id A unique integer value identifying this base plant.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApiInterface
      */
     retrieveBasePlant(id: string, options?: any): AxiosPromise<BasePlantObject>;
 
 }
 
 /**
  * ApiApi - object-oriented interface
  * @export
  * @class ApiApi
  * @extends {BaseAPI}
  */
 export class ApiApi extends BaseAPI implements ApiApiInterface {
     /**
      * 
      * @param {Email} [email] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApi
      */
     public createEmail(email?: Email, options?: any) {
         return ApiApiFp(this.configuration).createEmail(email, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {Feedback} [feedback] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApi
      */
     public createFeedback(feedback?: Feedback, options?: any) {
         return ApiApiFp(this.configuration).createFeedback(feedback, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {Installapp} [installapp] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApi
      */
     public createInstallapp(installapp?: Installapp, options?: any) {
         return ApiApiFp(this.configuration).createInstallapp(installapp, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {MyAuthToken} [myAuthToken] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApi
      */
     public createMyAuthToken(myAuthToken?: MyAuthToken, options?: any) {
         return ApiApiFp(this.configuration).createMyAuthToken(myAuthToken, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {PasswordToken} [passwordToken] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApi
      */
     public createPasswordToken(passwordToken?: PasswordToken, options?: any) {
         return ApiApiFp(this.configuration).createPasswordToken(passwordToken, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {Subscribe} [subscribe] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApi
      */
     public createSubscribe(subscribe?: Subscribe, options?: any) {
         return ApiApiFp(this.configuration).createSubscribe(subscribe, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {User} [user] 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApi
      */
     public createUser(user?: User, options?: any) {
         return ApiApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {number} [limit] Number of results to return per page.
      * @param {number} [offset] The initial index from which to return the results.
      * @param {string} [toxic] toxic
      * @param {string} [irritant] irritant
      * @param {string} [lifeSpan] life_span
      * @param {string} [pruning] pruning
      * @param {string} [fogging] fogging
      * @param {string} [cleaningPot] cleaning_pot
      * @param {string} [cleaningLeaves] cleaning_leaves
      * @param {string} [search] A search term.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApi
      */
     public listBasePlants(limit?: number, offset?: number, toxic?: string, irritant?: string, lifeSpan?: string, pruning?: string, fogging?: string, cleaningPot?: string, cleaningLeaves?: string, search?: string, options?: any) {
         return ApiApiFp(this.configuration).listBasePlants(limit, offset, toxic, irritant, lifeSpan, pruning, fogging, cleaningPot, cleaningLeaves, search, options).then((request) => request(this.axios, this.basePath));
     }
 
     /**
      * 
      * @param {string} id A unique integer value identifying this base plant.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ApiApi
      */
     public retrieveBasePlant(id: string, options?: any) {
         return ApiApiFp(this.configuration).retrieveBasePlant(id, options).then((request) => request(this.axios, this.basePath));
     }
 
 }
 
 
 